options{	static = false;}PARSER_BEGIN(AstParser)package parser;import java.util.ArrayList;import tac.TACProgram.Cond;import tac.TACProgram.Operator;public class AstParser{}PARSER_END(AstParser)SKIP :{	" "|	"\r"|	"\t"|	"\n"}TOKEN :{	< IF : "if" >|	< THEN : "then" >|	< ELSE : "else" >|	< WHILE : "while" >|	< DO : "do" >}TOKEN :{	< PLUS : "+" >|	< MINUS : "-" >|	< MULTIPLY : "*" >|	< DIVIDE : "/" >|	< LESSER : "<" >|	< GREATER : ">" >|	< EQUAL : "=" >|	< LB : "(" >|	< RB : ")" >}TOKEN :{	< INTEGER_DEC :  "0" | [ "1"-"9" ] ([ "0"-"9" ])* >|	< INTEGER_OCT : "0" ("0" | [ "1"-"7" ] ([ "0"-"7" ])*) >|	< INTEGER_HEX : "0" ("x" | "X") ([ "0"-"9", "a" - "f", "A" - "F" ])+ >|	< REAL_DEC : < INTEGER_DEC > "." ([ "0"-"9" ])+ >|	< REAL_OCT : < INTEGER_OCT > "." ([ "0"-"7" ])+ >|	< REAL_HEX : < INTEGER_HEX > "." ([ "0"-"9", "a" - "f", "A" - "F" ])+ >}TOKEN :{	< IDENTIFIER : < CHARACTER > (< CHARACTER > | < DIGIT >)* (("_"|".")(< CHARACTER > | < DIGIT >)+)? >|	< #CHARACTER : ["a" - "z", "A" - "Z"] >|	< #DIGIT : ["0" - "9"] >}TOKEN :{	< SEMICOLON : ";" >}SimpleNode Start() :{}{	StatementBlock() < EOF >	{		return jjtThis;	}}void StatementBlock() :{}{	(Statement())*}void Statement() #void :{}{	AssignmentStatement()|	IfStatement()|	WhileStatement()|	"{" StatementBlock() "}"}void AssignmentStatement() :{}{	Identifier() < EQUAL > Expression() < SEMICOLON >}void IfStatement() #void :{}{	//"Dangling else", see https://javacc.java.net/doc/lookahead.html	( ( < IF > Condition() < THEN > Statement() [ LOOKAHEAD(1) < ELSE > Statement() ] ) #IfElseStatement(>2) ) #IfStatement(>1)}void WhileStatement() :{}{	< WHILE > Condition() < DO > Statement()}void Condition() :{	Token token = null;}{	Expression()	(		token = < EQUAL >	|	token = < LESSER >	|	token = < GREATER >	)	Expression()	{		switch(token.kind)		{			case GREATER:				jjtThis.jjtSetValue(Cond.GREATER);				break;			case EQUAL:				jjtThis.jjtSetValue(Cond.EQUAL);				break;			case LESSER:				jjtThis.jjtSetValue(Cond.LESSER);				break;		}	}}void Expression() #void :{}{	AdditiveExpression()}void AdditiveExpression() #AdditiveExpression(>1) :{	ArrayList<Operator> operators = new ArrayList<Operator>(4);	Token token = null;}{	MultiplicativeExpression()	(		(			token = < PLUS >		|	token = < MINUS >		)		MultiplicativeExpression()		{			switch(token.kind)			{				case PLUS:					operators.add(Operator.ADD);					break;				case MINUS:					operators.add(Operator.SUB);					break;			}		}	)*	{		jjtThis.jjtSetValue(operators);	}}void MultiplicativeExpression() #MultiplicativeExpression(>1) :{	ArrayList<Operator> operators = new ArrayList<Operator>(4);	Token token = null;}{	UnaryExpression()	(		(			token = < MULTIPLY >		|	token = < DIVIDE >		)		UnaryExpression()		{			switch(token.kind)			{				case MULTIPLY:					operators.add(Operator.MUL);					break;				case DIVIDE:					operators.add(Operator.DIV);					break;			}		}	)*	{		jjtThis.jjtSetValue(operators);	}}void UnaryExpression() #void :{}{	< LB > Expression() < RB >|	Identifier()|	Number()}void Identifier() :{	Token token = null;}{	token = < IDENTIFIER >	{		jjtThis.jjtSetValue(token.image);	}}void Number() :{	Token token = null;}{	(		token = < INTEGER_DEC >	|	token = < INTEGER_OCT >	|	token = < INTEGER_HEX >	|	token = < REAL_DEC >	|	token = < REAL_OCT >	|	token = < REAL_HEX >	)	{		jjtThis.jjtSetValue(token.image);	}}