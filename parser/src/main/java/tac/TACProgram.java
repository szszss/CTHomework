package tac;

import java.util.ArrayList;
import java.util.List;

public final class TACProgram {
	
	private List<Variable> variables = new ArrayList<>();
	private List<Constant> constants = new ArrayList<>();
	private List<Temp> temps = new ArrayList<>();
	private List<Label> labels = new ArrayList<>();
	private List<TACCode> codes = new ArrayList<>(64);
	private int tempIndex = 0, labelIndex = 0;
	
	Variable variable(String name, boolean isParam) {
		Variable var = new Variable(name);
		var.param = isParam;
		variables.add(var);
		return var;
	}
	
	Temp temp() {
		Temp temp = new Temp("t" + tempIndex++);
		temps.add(temp);
		return temp;
	}
	
	Label label() {
		Label label = new Label("L" + labelIndex++);
		labels.add(label);
		codes.add(label);
		return label;
	}
	
	void assign(LValue target, Operator operator, RValue operand1, RValue operand2) {
		Assign assign = new Assign(target, operator, operand1, operand2);
		codes.add(assign);
	}
	
	JIT jit(Condition condition) {
		JIT jit = new JIT(condition);
		codes.add(jit);
		return jit;
	}
	
	Jump jump() {
		Jump jump = new Jump();
		codes.add(jump);
		return jump;
	}
	
	public String dump() {
		StringBuilder sb = new StringBuilder();
		for(TACCode code : codes)
		{
			sb.append(code).append("\r\n");
		}
		return sb.toString();
	}
	
	interface LValue {};
	
	interface RValue {};
	
	public class Constant implements RValue {
		final String value;
		
		public Constant(String value) {
			this.value = value;
		}
		
		@Override
		public String toString() {
			return value;
		}

		//-----------Generated by IDE------------
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((value == null) ? 0 : value.hashCode());
			return result;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Constant other = (Constant) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (value == null) {
				if (other.value != null)
					return false;
			} else if (!value.equals(other.value))
				return false;
			return true;
		}
		private TACProgram getOuterType() {
			return TACProgram.this;
		}
		public String getValue() {
			return value;
		}		
		//-------------------------------
	}
	
	public class Variable implements LValue, RValue {
		String name;
		boolean param = true;
		
		public Variable(String name) {
			this.name = name;
		}

		public String getName() {
			return name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public boolean isParam() {
			return param;
		}
		
		@Override
		public String toString() {
			return name;
		}
	}
	
	public class Temp implements LValue, RValue {
		String name;
		public Temp(String name) {
			this.name = name;
		}
		@Override
		public String toString() {
			return name;
		}
	}
	
	public class Condition {
		RValue left, right;
		Cond cond;
	}
	
	public abstract class TACCode {
		
	}
	
	public final class Label extends TACCode {
		String readableName;
		public Label(String name) {
			this.readableName = name;
		}
		@Override
		public String toString() {
			return readableName+":";
		}
	}
	
	public final class Assign extends TACCode {
		LValue operand0;
		Operator operator;
		RValue operand1, operand2;
		
		public Assign(LValue operand0, Operator operator, RValue operand1, RValue operand2) {
			super();
			this.operand0 = operand0;
			this.operator = operator;
			this.operand1 = operand1;
			this.operand2 = operand2;
		}
		
		@Override
		public String toString() {
			String str = operand0 + " := " + operand1;
			if(operator != Operator.ASSIGN)
				str += " " + operator + " " + operand2;
			return str;
		}
	}
	
	public class Jump extends TACCode {
		Label target;
	}
	
	public final class JIT extends Jump {
		Condition condition;
		
		public JIT(Condition condition) {
			this.condition = condition;
		}
	}
	
	public static enum Operator {
		ADD {
			@Override
			public String toString() {
				return "+";
			}
		}, SUB {
			@Override
			public String toString() {
				return "-";
			}
		}, MUL {
			@Override
			public String toString() {
				return "*";
			}
		}, DIV {
			@Override
			public String toString() {
				return "/";
			}
		}, ASSIGN;
	}
	
	public static enum Cond {
		GREATER {
			@Override
			public String toString() {
				return ">";
			}
		}, EQUAL {
			@Override
			public String toString() {
				return "=";
			}
		}, LESSER {
			@Override
			public String toString() {
				return "<";
			}
		};
	}
}
