package tac;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public final class TACProgram {
	
	private List<Variable> variables = new ArrayList<>();
	private List<Constant> constants = new ArrayList<>();
	private List<Temp> temps = new ArrayList<>();
	private List<Label> labels = new ArrayList<>();
	private List<TACCode> codes = new ArrayList<>(64);
	private int tempIndex = 0, labelIndex = 0;
	private boolean lastCodeIsLabel = false;
	private boolean linked = false;
	
	private void code(TACCode c) {
		codes.add(c);
		lastCodeIsLabel = false;
	}
	
	Variable variable(String name, boolean isParam) {
		Variable var = new Variable(name);
		var.param = isParam;
		variables.add(var);
		return var;
	}
	
	Constant constant(String value) {
		Constant constant = new Constant(value);
		constants.add(constant);
		return constant;
	}
	
	Temp temp() {
		Temp temp = new Temp("t" + tempIndex++);
		temps.add(temp);
		return temp;
	}
	
	Label label() {
		if(lastCodeIsLabel)
			return (Label)codes.get(codes.size()-1);
		Label label = new Label("L" + labelIndex++);
		labels.add(label);
		code(label);
		lastCodeIsLabel = true;
		return label;
	}
	
	void assign(LValue target, Operator operator, RValue operand1, RValue operand2) {
		Assign assign = new Assign(target, operator, operand1, operand2);
		code(assign);
	}
	
	JIT jit(Condition condition) {
		JIT jit = new JIT(condition);
		code(jit);
		return jit;
	}
	
	Jump jump() {
		Jump jump = new Jump();
		code(jump);
		return jump;
	}
	
	public String dump() {
		StringBuilder sb = new StringBuilder();
		for(TACCode code : codes)
		{
			sb.append(code).append("\r\n");
		}
		return sb.toString();
	}
	
	public void link() {
		if(!linked) {
			for(int i = 0; i < codes.size(); i++) {
				TACCode code = codes.get(i);
				if(code instanceof Label) {
					Label label = (Label)code;
					label.line = i;
				}
			}
			linked = true;
		}
	}
	
	List<Variable> getVariables() {
		return variables;
	}
	
	public List<TACCode> getCodes() {
		return codes;
	}

	interface LValue {
		abstract void writeValue(int value, Map<String, Integer> runtimeVars);
	};
	
	interface RValue {
		abstract int evalValue(Map<String, Integer> runtimeVars);
	};
	
	public class Constant implements RValue {
		final String value;
		
		public Constant(String value) {
			this.value = value;
		}
		
		@Override
		public String toString() {
			return value;
		}

		//-----------Generated by IDE------------
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + getOuterType().hashCode();
			result = prime * result + ((value == null) ? 0 : value.hashCode());
			return result;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			Constant other = (Constant) obj;
			if (!getOuterType().equals(other.getOuterType()))
				return false;
			if (value == null) {
				if (other.value != null)
					return false;
			} else if (!value.equals(other.value))
				return false;
			return true;
		}
		private TACProgram getOuterType() {
			return TACProgram.this;
		}
		public String getValue() {
			return value;
		}		
		//-------------------------------

		@Override
		public int evalValue(Map<String, Integer> runtimeVars) {
			return NumberUtil.getNumberInt(value);
		}
	}
	
	public class Variable implements LValue, RValue {
		String name;
		boolean param = true;
		
		public Variable(String name) {
			this.name = name;
		}

		public String getName() {
			return name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public boolean isParam() {
			return param;
		}
		
		@Override
		public String toString() {
			return name;
		}

		@Override
		public int evalValue(Map<String, Integer> runtimeVars) {
			return runtimeVars.get(name);
		}

		@Override
		public void writeValue(int value, Map<String, Integer> runtimeVars) {
			runtimeVars.put(name, value);
		}
	}
	
	public class Temp implements LValue, RValue {
		String name;
		public Temp(String name) {
			this.name = name;
		}
		@Override
		public String toString() {
			return name;
		}
		@Override
		public int evalValue(Map<String, Integer> runtimeVars) {
			return runtimeVars.get(name);
		}
		@Override
		public void writeValue(int value, Map<String, Integer> runtimeVars) {
			runtimeVars.put(name, value);
		}
	}
	
	public class Condition {
		RValue left, right;
		Cond cond;
		public Condition(RValue left, RValue right, Cond cond) {
			this.left = left;
			this.right = right;
			this.cond = cond;
		}
		@Override
		public String toString() {
			return left + " " + cond + " " + right;
		}
		public boolean eval(Map<String, Integer> runtimeVars) {
			return cond.eval(left, right, runtimeVars);
		}
	}
	
	public abstract class TACCode {
		public abstract int eval(int pc, Map<String, Integer> runtimeVars);
	}
	
	public final class Label extends TACCode {
		String readableName;
		int line = -1;
		public Label(String name) {
			this.readableName = name;
		}
		@Override
		public String toString() {
			return readableName+":";
		}
		@Override
		public int eval(int pc, Map<String, Integer> runtimeVars) {
			return pc+1;
		}
	}
	
	public final class Assign extends TACCode {
		LValue operand0;
		Operator operator;
		RValue operand1, operand2;
		
		public Assign(LValue operand0, Operator operator, RValue operand1, RValue operand2) {
			super();
			this.operand0 = operand0;
			this.operator = operator;
			this.operand1 = operand1;
			this.operand2 = operand2;
		}
		
		@Override
		public String toString() {
			String str = operand0 + " := " + operand1;
			if(operator != Operator.ASSIGN)
				str += " " + operator + " " + operand2;
			return str;
		}
		@Override
		public int eval(int pc, Map<String, Integer> runtimeVars) {
			operand0.writeValue(operator.eval(operand1, operand2, runtimeVars), runtimeVars);
			return pc+1;
		}
	}
	
	public class Jump extends TACCode {
		Label target;
		@Override
		public String toString() {
			return "goto " + target.readableName;
		}
		@Override
		public int eval(int pc, Map<String, Integer> runtimeVars) {
			return target.line + 1;
		}
	}
	
	public final class JIT extends Jump {
		Condition condition;
		
		public JIT(Condition condition) {
			this.condition = condition;
		}
		
		@Override
		public String toString() {
			return "if " + condition + " goto " + target.readableName;
		}
		
		@Override
		public int eval(int pc, Map<String, Integer> runtimeVars) {
			if(condition.eval(runtimeVars))
				return target.line + 1;
			return pc + 1;
		}
	}
	
	public static enum Operator {
		ADD {
			@Override
			public String toString() {
				return "+";
			}

			@Override
			public int eval(RValue v1, RValue v2, Map<String, Integer> runtimeVars) {
				return v1.evalValue(runtimeVars) + v2.evalValue(runtimeVars);
			}
		}, SUB {
			@Override
			public String toString() {
				return "-";
			}

			@Override
			public int eval(RValue v1, RValue v2, Map<String, Integer> runtimeVars) {
				return v1.evalValue(runtimeVars) - v2.evalValue(runtimeVars);
			}
		}, MUL {
			@Override
			public String toString() {
				return "*";
			}

			@Override
			public int eval(RValue v1, RValue v2, Map<String, Integer> runtimeVars) {
				return v1.evalValue(runtimeVars) * v2.evalValue(runtimeVars);
			}
		}, DIV {
			@Override
			public String toString() {
				return "/";
			}

			@Override
			public int eval(RValue v1, RValue v2, Map<String, Integer> runtimeVars) {
				return v1.evalValue(runtimeVars) / v2.evalValue(runtimeVars);
			}
		}, ASSIGN {
			@Override
			public int eval(RValue v1, RValue v2, Map<String, Integer> runtimeVars) {
				return v1.evalValue(runtimeVars);
			}
		};
		
		public abstract int eval(RValue v1, RValue v2, Map<String, Integer> runtimeVars);
	}
	
	public static enum Cond {
		GREATER {
			@Override
			public String toString() {
				return ">";
			}

			@Override
			public boolean eval(RValue v1, RValue v2, Map<String, Integer> runtimeVars) {
				return v1.evalValue(runtimeVars) > v2.evalValue(runtimeVars);
			}
		}, EQUAL {
			@Override
			public String toString() {
				return "=";
			}

			@Override
			public boolean eval(RValue v1, RValue v2, Map<String, Integer> runtimeVars) {
				return v1.evalValue(runtimeVars) == v2.evalValue(runtimeVars);
			}
		}, LESSER {
			@Override
			public String toString() {
				return "<";
			}

			@Override
			public boolean eval(RValue v1, RValue v2, Map<String, Integer> runtimeVars) {
				return v1.evalValue(runtimeVars) < v2.evalValue(runtimeVars);
			}
		};
		
		public abstract boolean eval(RValue v1, RValue v2, Map<String, Integer> runtimeVars);
	}
}
